{"version":3,"sources":["../src/index.ts"],"names":["generateRandomString","level","index","str","Math","random","toString","substr","generateCascade","name","value","CascadeHelper","subKey","valueKey","cascades","options","labels","itemSeparator","endLevel","results","iteratorCascades","strs","path","cascade","cStrs","label","cLevel","cPath","push","count","generateFunc","startLevel","newCascades","setInit","xIndex","item","cb","deepForEach","parent","levelCount","acc","_curr","join","values","prevLevel","iteratorSubCascades","subCascades","targetValue","current","currentIndex","levelSeparator","parseLabels","tArr","result","curr","newCurr","length","key","trimedStr","arr","split","deepFlatten"],"mappings":"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","sourcesContent":["import { isEmpty, forEach, isUndefined, cloneDeep, get, trim, find, filter, map, reduce, indexOf, times } from 'lodash'\n\nexport interface Cascade {\n  [key: string]: any\n}\n\ninterface Strs {\n  [key: string]: string\n}\n\ninterface Values {\n  [key: string]: any\n}\n\ninterface FlattenResult {\n  strs: Strs\n  cascade: Cascade\n  path: string\n}\ntype DeepForEachCallback = (cascade: Cascade, currentLevel: number, currentIndex: number) => void\ntype DeepMapCallback = (\n  cascade: Cascade,\n  currentLevel: number,\n  currentIndex: number,\n  path: string,\n  parent?: Cascade\n) => void\n\nexport const generateRandomString = (level = 0, index = 0): string => {\n  const str = Math.random()\n    .toString(36)\n    .substr(2, 7)\n\n  return str + '-' + level + '-' + index\n}\n\nconst generateCascade = (level: number, index: number): Cascade => ({\n  name: `${level}.${index}`,\n  value: generateRandomString(level, index),\n})\n\nclass CascadeHelper {\n  public subKey: string\n  public valueKey: string\n  public constructor(subKey = 'children', valueKey = 'value') {\n    this.subKey = subKey\n    this.valueKey = valueKey\n  }\n\n  public deepFlatten(\n    cascades: Cascade[],\n    options?: { labels?: string[]; itemSeparator?: string; endLevel?: number }\n  ): FlattenResult[] {\n    const labels = get(options, 'labels') || []\n    const itemSeparator = get(options, 'itemSeparator') || '-'\n    const endLevel = get(options, 'endLevel')\n\n    const results: FlattenResult[] = []\n    const { subKey } = this\n\n    const iteratorCascades = (cascades: Cascade[], strs: Strs = {}, path?: string, level?: number): void => {\n      forEach(cascades, (cascade, index) => {\n        const cStrs: Strs = {}\n        forEach(labels, (label) => {\n          cStrs[label] = !isUndefined(strs[label]) ? strs[label] + itemSeparator + cascade[label] : cascade[label]\n        })\n\n        let cLevel = !isUndefined(level) ? level : 0\n        const cPath = !isUndefined(path) ? `${path}.${subKey}[${index}]` : `[${index}]`\n\n        if (!isEmpty(cascade[subKey]) && (isUndefined(endLevel) || (!isUndefined(endLevel) && cLevel < endLevel))) {\n          cLevel++\n          return iteratorCascades(cascade[subKey], cStrs, cPath, cLevel)\n        }\n\n        results.push({ strs: cStrs, cascade: cloneDeep(cascade), path: cPath })\n      })\n    }\n\n    iteratorCascades(cascades)\n    return results\n  }\n\n  /*\n   * Fill cascade\n   */\n  public deepFill(\n    cascades: Cascade[] = [],\n    options?: {\n      count?: number\n      generateFunc?: (level: number, index: number) => Cascade\n      startLevel?: number\n      endLevel?: number\n    }\n  ): Cascade[] {\n    const count = get(options, 'count') || 2\n    const generateFunc = get(options, 'generateFunc') || generateCascade\n    const startLevel = get(options, 'startLevel') || 0\n    const endLevel = get(options, 'endLevel') || 1\n\n    const { subKey } = this\n    const newCascades = { [subKey]: cloneDeep(cascades) }\n\n    if (startLevel > endLevel) {\n      return newCascades[subKey]\n    }\n\n    const setInit = (level: number, cascade: Cascade): void => {\n      if (isUndefined(cascade[subKey])) {\n        cascade[subKey] = []\n      }\n\n      if (isEmpty(cascade[subKey])) {\n        times(count, (xIndex) => {\n          if (isUndefined(cascade[subKey][xIndex])) {\n            cascade[subKey][xIndex] = generateFunc(level, xIndex)\n          }\n        })\n      }\n\n      forEach(cascade[subKey], (item) => {\n        if (level < endLevel) {\n          setInit(level + 1, item)\n        }\n      })\n    }\n\n    setInit(startLevel, newCascades)\n    return newCascades[subKey]\n  }\n\n  /*\n   * For each cascade\n   */\n  public deepForEach(\n    cascades: Cascade[],\n    cb: DeepForEachCallback,\n    options?: { startLevel?: number; endLevel?: number }\n  ): void {\n    const startLevel = get(options, 'startLevel') || 0\n    const endLevel = get(options, 'endLevel')\n    const { subKey } = this\n\n    forEach(cascades, (cascade, index) => {\n      cb(cascade, startLevel, index)\n      if (!isEmpty(cascade[subKey])) {\n        if (endLevel && startLevel >= endLevel) {\n          return\n        }\n\n        this.deepForEach(cascade[subKey], cb, { startLevel: startLevel + 1, endLevel })\n      }\n    })\n  }\n\n  /*\n   * Map cascades\n   */\n  public deepMap(cascades: Cascade[], cb: DeepMapCallback, options?: { startLevel?: number }): any[] {\n    const { subKey } = this\n    const newCascades = cloneDeep(cascades)\n\n    const iteratorCascades = (\n      cascades: Cascade[],\n      cb: DeepMapCallback,\n      options?: { startLevel?: number; parent?: Cascade; path?: string }\n    ): any[] => {\n      const startLevel = get(options, 'startLevel') || 0\n      const parent = get(options, 'parent')\n      const path = get(options, 'path')\n\n      return map(cascades, (cascade, index) => {\n        const cPath = !isUndefined(path) ? `${path}.${subKey}[${index}]` : `[${index}]`\n\n        if (!isEmpty(cascade[subKey])) {\n          cascade[subKey] = iteratorCascades(cascade[subKey], cb, {\n            startLevel: startLevel + 1,\n            parent: cascade,\n            path: cPath,\n          })\n        }\n\n        return cb(cascade, startLevel, index, cPath, parent)\n      })\n    }\n\n    return iteratorCascades(newCascades, cb, { startLevel: get(options, 'startLevel') })\n  }\n\n  /*\n   * Get init values\n   * Get the first value of cascades by default\n   */\n  public initValues(cascades: Cascade[], levelCount: number, index = 0): Values {\n    const { subKey, valueKey } = this\n\n    return reduce<any, { [key: string]: string }>(\n      times(levelCount),\n      (acc, _curr, level) => {\n        acc[`level${level}`] = get(\n          cascades,\n          `[${index}]` + times(level, () => `${subKey}[${index}]`).join('.') + valueKey\n        )\n        return acc\n      },\n      {}\n    )\n  }\n\n  /*\n   * Get the specified level cascades by current values\n   */\n  public getLevelCascades(\n    cascades: Cascade[],\n    values: Values,\n    level: number\n  ): {\n    cascades: Cascade[]\n    path: string\n    parent: Cascade | null\n  } {\n    let path = ''\n    const { subKey, valueKey } = this\n\n    if (level <= 0) {\n      return { cascades: cascades || [], path, parent: null }\n    }\n\n    const prevLevel = level - 1\n    if (values && isEmpty(values[`level${prevLevel}`])) {\n      return { cascades: [], path, parent: null }\n    }\n\n    const iteratorSubCascades = (startLevel: number, endLevel: number, subCascades: Cascade[]): any => {\n      const targetValue = values && values[`level${startLevel}`]\n      const current = find(subCascades, (cascade) => get(cascade, valueKey) === targetValue)\n      const currentIndex = indexOf(subCascades, current)\n      path += `[${currentIndex}].${subKey}`\n\n      if (!current) {\n        return { subCascades: [], parent: null }\n      }\n\n      if (startLevel >= endLevel) {\n        return {\n          subCascades: current[subKey] || [],\n          parent: { cascade: current, index: currentIndex, level: startLevel },\n        }\n      }\n\n      return iteratorSubCascades(startLevel + 1, endLevel, current[subKey] || [])\n    }\n\n    const { subCascades, parent } = iteratorSubCascades(0, prevLevel, cascades)\n    return { cascades: subCascades, path, parent }\n  }\n\n  /*\n   * To structure cascades by text\n   */\n  public parse(\n    str: string,\n    cb: (key: string, valueKey: string, level: number, index: number) => Cascade,\n    options?: { itemSeparator?: string; levelSeparator?: string }\n  ): Cascade[] {\n    const itemSeparator = get(options, 'itemSeparator') || '-'\n    const levelSeparator = get(options, 'levelSeparator') || '\\n'\n\n    const { subKey, valueKey } = this\n    const parseLabels = (tArr: string[][], level = 0): Cascade[] => {\n      const result = reduce<any, { [key: string]: string[][] }>(\n        tArr,\n        (acc, curr) => {\n          if (!acc[curr[0]]) {\n            acc[curr[0]] = []\n          }\n          const newCurr = filter(curr, (item) => item !== curr[0])\n          if (newCurr.length > 0) {\n            acc[curr[0]] = [...acc[curr[0]], newCurr]\n          }\n\n          return acc\n        },\n        {}\n      )\n      const cLevel = level\n      let index = 0\n      level++\n      return map(result, (item, key) => {\n        let cascade\n\n        if (isEmpty(item)) {\n          cascade = { ...cb(key, valueKey, cLevel, index) }\n        } else {\n          cascade = {\n            [subKey]: parseLabels(item, level),\n            ...cb(key, valueKey, cLevel, index),\n          }\n        }\n\n        index++\n        return cascade\n      })\n    }\n\n    const trimedStr = trim(str)\n    if (isEmpty(trimedStr)) {\n      return []\n    }\n    const arr = trimedStr.split(levelSeparator)\n    const tArr = map(arr, (item) => item.split(itemSeparator))\n\n    return parseLabels(tArr)\n  }\n\n  /*\n   * Serialize string to cascades\n   */\n\n  public stringify(\n    cascades: Cascade[],\n    label: string,\n    options?: { itemSeparator?: string; levelSeparator?: string; endLevel?: number }\n  ): string {\n    const itemSeparator = get(options, 'itemSeparator') || '-'\n    const levelSeparator = get(options, 'levelSeparator') || '\\n'\n    const endLevel = get(options, 'endLevel')\n\n    const results = this.deepFlatten(cascades, { labels: [label], itemSeparator, endLevel })\n    return map(results, (item) => item.strs[label]).join(levelSeparator)\n  }\n}\n\nexport default CascadeHelper\n"],"file":"index.js"}